{"version":3,"sources":["node_modules/@ctrip/crnweb/src/react-native/apis/Animated/Interpolation.web.js"],"names":["linear","t","Interpolation","config","outputRange","createInterpolationFromStringOutputRange","inputRange","easing","extrapolateLeft","undefined","extrapolate","extrapolateRight","input","range","findRange","interpolate","createInterpolation","checkInfiniteRange","checkValidInputRange","length","arr","i","name","Infinity","inputMin","inputMax","outputMin","outputMax","result","colorToRgba","int32Color","r","g","b","a","stringShapeRegex","map","outputRanges","match","forEach","value","number","push","interpolations","create","replace","String"],"mappings":"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","file":"Interpolation.web.js","sourceRoot":"/Users/jane/Documents/HaloAI","sourcesContent":["\n\n'use strict';\n\nimport normalizeColor from './../../modules/react-lib/normalizeColor';\nimport invariant from 'fbjs/lib/invariant';\n\nlet linear = (t) => t;\n\n/**\n * Very handy helper to map input ranges to output ranges with an easing\n * function and custom behavior outside of the ranges.\n */\nclass Interpolation {\n  static create(config) {\n\n    if (config.outputRange && typeof config.outputRange[0] === 'string') {\n      return createInterpolationFromStringOutputRange(config);\n    }\n\n    let outputRange = config.outputRange;\n\n      let inputRange = config.inputRange;\n\n\n      let easing = config.easing || linear;\n\n      let extrapolateLeft = 'extend';\n    if (config.extrapolateLeft !== undefined) {\n      extrapolateLeft = config.extrapolateLeft;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateLeft = config.extrapolate;\n    }\n\n      let extrapolateRight  = 'extend';\n    if (config.extrapolateRight !== undefined) {\n      extrapolateRight = config.extrapolateRight;\n    } else if (config.extrapolate !== undefined) {\n      extrapolateRight = config.extrapolate;\n    }\n\n    return (input) => {\n\n\n        let range = findRange(input, inputRange);\n      return interpolate(\n        input,\n        inputRange[range],\n        inputRange[range + 1],\n        outputRange[range],\n        outputRange[range + 1],\n        easing,\n        extrapolateLeft,\n        extrapolateRight,\n      );\n    };\n  }\n}\n\nfunction createInterpolation(config){\n    if (config.outputRange && typeof config.outputRange[0] === 'string') {\n        return createInterpolationFromStringOutputRange(config);\n    }\n\n    const outputRange = config.outputRange;\n    checkInfiniteRange('outputRange', outputRange);\n\n    const inputRange = config.inputRange;\n    checkInfiniteRange('inputRange', inputRange);\n    checkValidInputRange(inputRange);\n\n    invariant(\n        inputRange.length === outputRange.length,\n        'inputRange (' +\n        inputRange.length +\n        ') and outputRange (' +\n        outputRange.length +\n        ') must have the same length',\n    );\n\n    const easing = config.easing || linear;\n\n    let extrapolateLeft = 'extend';\n    if (config.extrapolateLeft !== undefined) {\n        extrapolateLeft = config.extrapolateLeft;\n    } else if (config.extrapolate !== undefined) {\n        extrapolateLeft = config.extrapolate;\n    }\n\n    let extrapolateRight = 'extend';\n    if (config.extrapolateRight !== undefined) {\n        extrapolateRight = config.extrapolateRight;\n    } else if (config.extrapolate !== undefined) {\n        extrapolateRight = config.extrapolate;\n    }\n\n    return input => {\n        invariant(\n            typeof input === 'number',\n            'Cannot interpolation an input which is not a number',\n        );\n\n        const range = findRange(input, inputRange);\n        return interpolate(\n            input,\n            inputRange[range],\n            inputRange[range + 1],\n            outputRange[range],\n            outputRange[range + 1],\n            easing,\n            extrapolateLeft,\n            extrapolateRight,\n        );\n    };\n}\n\nfunction checkValidInputRange(arr) {\n    invariant(arr.length >= 2, 'inputRange must have at least 2 elements');\n    for (let i = 1; i < arr.length; ++i) {\n        invariant(\n            arr[i] >= arr[i - 1],\n            /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n             * one or both of the operands may be something that doesn't cleanly\n             * convert to a string, like undefined, null, and object, etc. If you really\n             * mean this implicit string conversion, you can do something like\n             * String(myThing)\n             */\n            'inputRange must be monotonically increasing ' + arr,\n        );\n    }\n}\n\nfunction checkInfiniteRange(name, arr) {\n    invariant(arr.length >= 2, name + ' must have at least 2 elements');\n    invariant(\n        arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity,\n        /* $FlowFixMe(>=0.13.0) - In the addition expression below this comment,\n         * one or both of the operands may be something that doesn't cleanly convert\n         * to a string, like undefined, null, and object, etc. If you really mean\n         * this implicit string conversion, you can do something like\n         * String(myThing)\n         */\n        name + 'cannot be ]-infinity;+infinity[ ' + arr,\n    );\n}\n\nfunction interpolate(\n  input,\n  inputMin,\n  inputMax,\n  outputMin,\n  outputMax,\n  easing,\n  extrapolateLeft,\n  extrapolateRight,\n) {\n    let result = input;\n\n  // Extrapolate\n  if (result < inputMin) {\n    if (extrapolateLeft === 'identity') {\n      return result;\n    } else if (extrapolateLeft === 'clamp') {\n      result = inputMin;\n    } else if (extrapolateLeft === 'extend') {\n      // noop\n    }\n  }\n\n  if (result > inputMax) {\n    if (extrapolateRight === 'identity') {\n      return result;\n    } else if (extrapolateRight === 'clamp') {\n      result = inputMax;\n    } else if (extrapolateRight === 'extend') {\n      // noop\n    }\n  }\n\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n\n  if (inputMin === inputMax) {\n    if (input <= inputMin) {\n      return outputMin;\n    }\n    return outputMax;\n  }\n\n  // Input Range\n  if (inputMin === -Infinity) {\n    result = -result;\n  } else if (inputMax === Infinity) {\n    result = result - inputMin;\n  } else {\n    result = (result - inputMin) / (inputMax - inputMin);\n  }\n\n  // Easing\n  result = easing(result);\n\n  // Output Range\n  if (outputMin === -Infinity) {\n    result = -result;\n  } else if (outputMax === Infinity) {\n    result = result + outputMin;\n  } else {\n    result = result * (outputMax - outputMin) + outputMin;\n  }\n\n  return result;\n}\n\nfunction colorToRgba(input) {\n    let int32Color = normalizeColor(input);\n  if (int32Color === null) {\n    return input;\n  }\n\n  int32Color = int32Color || 0; // $FlowIssue\n\n    let r = (int32Color & 0xff000000) >>> 24;\n    let g = (int32Color & 0x00ff0000) >>> 16;\n    let b = (int32Color & 0x0000ff00) >>> 8;\n    let a = (int32Color & 0x000000ff) / 255;\n\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\nlet stringShapeRegex = /[0-9\\.-]+/g;\n\n/**\n * Supports string shapes by extracting numbers so new values can be computed,\n * and recombines those values into new strings of the same shape.  Supports\n * things like:\n *\n *   rgba(123, 42, 99, 0.36) // colors\n *   -45deg                  // values with units\n */\nfunction createInterpolationFromStringOutputRange(\n  config,\n) {\n  let outputRange= config.outputRange;\n  outputRange = outputRange.map(colorToRgba);\n  // checkPattern(outputRange);\n\n  // ['rgba(0, 100, 200, 0)', 'rgba(50, 150, 250, 0.5)']\n  // ->\n  // [\n  //   [0, 50],\n  //   [100, 150],\n  //   [200, 250],\n  //   [0, 0.5],\n  // ]\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  let outputRanges = outputRange[0].match(stringShapeRegex).map(() => []);\n  outputRange.forEach(value => {\n    /* $FlowFixMe(>=0.18.0): `value.match()` can return `null`. Need to guard\n     * against this possibility.\n     */\n    value.match(stringShapeRegex).forEach((number, i) => {\n      outputRanges[i].push(+number);\n    });\n  });\n\n  /* $FlowFixMe(>=0.18.0): `outputRange[0].match()` can return `null`. Need to\n   * guard against this possibility.\n   */\n  let interpolations = outputRange[0].match(stringShapeRegex).map((value, i) => {\n    return Interpolation.create({\n      ...config,\n      outputRange: outputRanges[i],\n    });\n  });\n\n  return (input) => {\n    let i = 0;\n    // 'rgba(0, 100, 200, 0)'\n    // ->\n    // 'rgba(${interpolations[0](input)}, ${interpolations[1](input)}, ...'\n    return outputRange[0].replace(stringShapeRegex, () => {\n      return String(interpolations[i++](input));\n    });\n  };\n}\n\n\nfunction findRange(input, inputRange) {\n  let i=1;\n  for (; i < inputRange.length-1; ++i) {\n    if (inputRange[i] >= input) {\n        return i - 1;\n    }\n  }\n  return i-1;\n}\nInterpolation.createInterpolation = createInterpolation;\nexport default Interpolation;\n"]}