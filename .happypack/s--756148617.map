{"version":3,"sources":["node_modules/@ctrip/crnweb/src/react-native/components/Touchable/Touchable.web.js"],"names":["States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","IsActive","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","WrappedComponent","TouchableMixin","props","args","touchableDelayTimeout","clearTimeout","longPressDelayTimeout","pressOutDelayTimeout","touchable","touchState","undefined","responderID","rejectResponderTermination","disabled","e","dispatchID","persist","type","state","_receiveSignal","delayMS","touchableGetHighlightDelayMS","Math","max","isNaN","setTimeout","_handleDelay","bind","longDelayMS","touchableGetLongPressDelayMS","_handleLongDelay","preventDefault","global","currentApp","globalTouchMove","moveFlag","target","moveTarget","touchableHandleResponderTerminate","touchableHandleActivePressOut","positionOnActivate","dimensionsOnActivate","pressRectOffset","touchableGetPressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touchableGetHitSlop","touch","TouchEventUtils","extractSingleTouch","nativeEvent","pageX","pageY","pressInLocation","movedDistance","_getDistanceBetweenPoints","_cancelLongPressDelayTimeout","isTouchWithinActive","width","height","curState","console","signal","nextState","Error","_performSideEffectsForTransition","locationX","locationY","aX","aY","bX","bY","deltaX","deltaY","sqrt","curIsHighlight","_isHighlight","newIsHighlight","isFinalSignal","_remeasureMetricsOnActivation","touchableHandleLongPress","_savePressInLocation","touchableHandleActivePressIn","touchableGetPressOutDelayMS","hasLongPressHandler","onLongPress","pressIsLongButStillCallOnPress","touchableLongPressCancelsPress","shouldInvokePress","touchableHandlePress","document","activeElement","blur","focus"],"mappings":"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","file":"Touchable.web.js","sourceRoot":"/Users/jane/Documents/HaloAI","sourcesContent":["\n'use strict';\n\nimport React,{Component} from 'react';\n\nimport TouchEventUtils from 'fbjs/lib/TouchEventUtils'\n\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\n\n\nlet States = {\n  NOT_RESPONDER: \"NOT_RESPONDER\",\n  RESPONDER_INACTIVE_PRESS_IN: \"RESPONDER_INACTIVE_PRESS_IN\",\n  RESPONDER_INACTIVE_PRESS_OUT: \"RESPONDER_INACTIVE_PRESS_OUT\",\n  RESPONDER_ACTIVE_PRESS_IN: \"RESPONDER_ACTIVE_PRESS_IN\",\n  RESPONDER_ACTIVE_PRESS_OUT: \"RESPONDER_ACTIVE_PRESS_OUT\",\n  RESPONDER_ACTIVE_LONG_PRESS_IN: \"RESPONDER_ACTIVE_LONG_PRESS_IN\",\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: \"RESPONDER_ACTIVE_LONG_PRESS_OUT\",\n  ERROR: \"ERROR\"\n};\n\n\n\n\n\n\n\n/**\n * Quick lookup map for states that are considered to be \"active\"\n */\nlet IsActive = {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n};\n\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\nlet IsPressingIn = {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true,\n};\n\nlet IsLongPressingIn = {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true,\n};\n\n/**\n * Inputs to the state machine.\n */\nlet Signals = {\n  DELAY: \"DELAY\",\n  RESPONDER_GRANT: \"RESPONDER_GRANT\",\n  RESPONDER_RELEASE: \"RESPONDER_RELEASE\",\n  RESPONDER_TERMINATED: \"RESPONDER_TERMINATED\",\n  ENTER_PRESS_RECT: \"ENTER_PRESS_RECT\",\n  LEAVE_PRESS_RECT: \"LEAVE_PRESS_RECT\",\n  LONG_PRESS_DETECTED: \"LONG_PRESS_DETECTED\"\n};\n\n/**\n * Mapping from States x Signals => States\n */\nlet Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    // TODO this fix chrome debug error, should set back when publish\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN, //States.ERROR,\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR,\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER,\n  }\n};\n\n// ==== Typical Constants for integrating into UI components ====\nlet HIGHLIGHT_DELAY_MS = 130;\n\nlet PRESS_EXPAND_PX = 20;\n\nlet LONG_PRESS_THRESHOLD = 500;\n\nlet LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\n\nlet LONG_PRESS_ALLOWED_MOVEMENT = 10;\n\n\nexport default (WrappedComponent) => {\n    class TouchableMixin extends WrappedComponent {\n        constructor(props){\n            super(props);\n        }\n\n        render() {\n            return super.render();\n        }\n        /**\n         * Clear all timeouts on unmount\n         */\n        componentWillUnmount(...args) {\n            super.componentWillUnmount && super.componentWillUnmount(...args);\n            this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n            this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n            this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n        }\n\n        /**\n         * It's prefer that mixins determine state in this way, having the class\n         * explicitly mix the state in the one and only `getInitialState` method.\n         *\n         * @return {object} State object to be placed inside of\n         * `this.state.touchable`.\n         */\n        touchableGetInitialState() {\n            return {\n                touchable: {touchState: undefined, responderID: null}\n            };\n        }\n\n        // ==== Hooks to Gesture Responder system ====\n        /**\n         * Must return true if embedded in a native platform scroll view.\n         */\n        touchableHandleResponderTerminationRequest() {\n            return !this.props.rejectResponderTermination;\n        }\n\n        /**\n         * Must return true to start the process of `Touchable`.\n         */\n        touchableHandleStartShouldSetResponder() {\n            // return true;\n\t        return !this.props.disabled;//啟用disabled屬性\n        }\n\n        /**\n         * Return true to cancel press on long press.\n         */\n        touchableLongPressCancelsPress () {\n            return true;\n        }\n\n        /**\n         * Place as callback for a DOM element's `onResponderGrant` event.\n         * @param {SyntheticEvent} e Synthetic event from event system.\n         * @param {string} dispatchID ID of node that e was dispatched to.\n         *\n         */\n        touchableHandleResponderGrant(e, dispatchID) {\n            // Since e is used in a callback invoked on another event loop\n            // (as in setTimeout etc), we need to call e.persist() on the\n            // event to make sure it doesn't get reused in the event object pool.\n            e.persist();\n            if(e.type==\"touchmove\"){\n                return false;\n            };\n            this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n            this.pressOutDelayTimeout = null;\n\n            this.state.touchable.touchState = States.NOT_RESPONDER;\n            this.state.touchable.responderID = dispatchID;\n            // console.log(\"RESPONDER_GRANT-\"+(new Date()-global.startTime))\n            this._receiveSignal(Signals.RESPONDER_GRANT, e);\n            let delayMS =\n                this.touchableGetHighlightDelayMS !== undefined ?\n                    Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n            delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n            if (delayMS !== 0) {\n                this.touchableDelayTimeout = setTimeout(\n                    this._handleDelay.bind(this, e),\n                    delayMS\n                );\n            } else {\n                this._handleDelay(e);\n            }\n\n            let longDelayMS =\n                this.touchableGetLongPressDelayMS !== undefined ?\n                    Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n            longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n            this.longPressDelayTimeout = setTimeout(\n                this._handleLongDelay.bind(this, e),\n                longDelayMS + delayMS\n            );\n        }\n\n        /**\n         * Place as callback for a DOM element's `onResponderRelease` event.\n         */\n        touchableHandleResponderRelease(e) {\n            // 防止下面是textinput出现点透事件\n            e.preventDefault();\n            // console.log(\"RESPONDER_RELEASE-\"+(new Date()-global.startTime))\n            //修复ios浏览器中从头部开始下拉时不会触发touchmove事件，导致press事件被触发的问题。\n            if(global.currentApp.globalTouchMove&&global.currentApp.globalTouchMove.moveFlag){\n                global.currentApp.globalTouchMove.moveFlag=false;\n                if(e.target==global.currentApp.globalTouchMove.moveTarget){\n                    this.touchableHandleResponderTerminate(e);\n                    return;\n                }\n            }\n\n            this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n        }\n\n        /**\n         * Place as callback for a DOM element's `onResponderTerminate` event.\n         */\n        touchableHandleResponderTerminate(e) {\n            // 防止下面是textinput\n            // e.preventDefault();\n            // console.log(\"RESPONDER_TERMINATED\")\n            if(e.type==\"touchmove\"){\n                this.touchableHandleActivePressOut(e);\n                return;\n            }else {\n                this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n            }\n        }\n\n        /**\n         * Place as callback for a DOM element's `onResponderMove` event.\n         */\n        touchableHandleResponderMove(e) {\n            // Not enough time elapsed yet, wait for highlight -\n            // this is just a perf optimization.\n            if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {\n                return;\n            }\n\n            // Measurement may not have returned yet.\n            if (!this.state.touchable.positionOnActivate) {\n                return;\n            }\n\n            let positionOnActivate = this.state.touchable.positionOnActivate;\n            let dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n            let pressRectOffset = this.touchableGetPressRectOffset ?\n                this.touchableGetPressRectOffset() : {\n                    left: PRESS_EXPAND_PX,\n                    right: PRESS_EXPAND_PX,\n                    top: PRESS_EXPAND_PX,\n                    bottom: PRESS_EXPAND_PX\n                };\n\n            let pressExpandLeft = pressRectOffset.left;\n            let pressExpandTop = pressRectOffset.top;\n            let pressExpandRight = pressRectOffset.right;\n            let pressExpandBottom = pressRectOffset.bottom;\n\n            let hitSlop = this.touchableGetHitSlop ?\n                this.touchableGetHitSlop() : null;\n\n            if (hitSlop) {\n                pressExpandLeft += hitSlop.left;\n                pressExpandTop += hitSlop.top;\n                pressExpandRight += hitSlop.right;\n                pressExpandBottom += hitSlop.bottom;\n            }\n\n            let touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n            let pageX = touch && touch.pageX;\n            let pageY = touch && touch.pageY;\n\n            if (this.pressInLocation) {\n                let movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n                if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n                    this._cancelLongPressDelayTimeout();\n                }\n            }\n\n            let isTouchWithinActive =\n                pageX > positionOnActivate.left - pressExpandLeft &&\n                pageY > positionOnActivate.top - pressExpandTop &&\n                pageX <\n                positionOnActivate.left +\n                dimensionsOnActivate.width +\n                pressExpandRight &&\n                pageY <\n                positionOnActivate.top +\n                dimensionsOnActivate.height +\n                pressExpandBottom;\n            if (isTouchWithinActive) {\n                // console.log(\"ENTER_PRESS_RECT\");\n                this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n                let curState = this.state.touchable.touchState;\n                if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {\n                    // fix for t7967420\n                    this._cancelLongPressDelayTimeout();\n                }\n            } else {\n                // console.log(\"LEAVE_PRESS_RECT\");\n                this._cancelLongPressDelayTimeout();\n                this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n            }\n        }\n\n        // ==== Abstract Application Callbacks ====\n\n        /**\n         * Invoked when the item should be highlighted. Mixers should implement this\n         * to visually distinguish the `VisualRect` so that the user knows that\n         * releasing a touch will result in a \"selection\" (analog to click).\n         *\n         * @abstract\n         * touchableHandleActivePressIn: function,\n         */\n\n        /**\n         * Invoked when the item is \"active\" (in that it is still eligible to become\n         * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n         * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n         * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n         * again and the mixer should probably highlight the `VisualRect` again. This\n         * event will not fire on an `touchEnd/mouseUp` event, only move events while\n         * the user is depressing the mouse/touch.\n         *\n         * @abstract\n         * touchableHandleActivePressOut: function\n         */\n\n        /**\n         * Invoked when the item is \"selected\" - meaning the interaction ended by\n         * letting up while the item was either in the state\n         * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n         *\n         * @abstract\n         * touchableHandlePress: function\n         */\n\n        /**\n         * Invoked when the item is long pressed - meaning the interaction ended by\n         * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n         * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n         * be called as it normally is. If `touchableHandleLongPress` is provided, by\n         * default any `touchableHandlePress` callback will not be invoked. To\n         * override this default behavior, override `touchableLongPressCancelsPress`\n         * to return false. As a result, `touchableHandlePress` will be called when\n         * lifting up, even if `touchableHandleLongPress` has also been called.\n         *\n         * @abstract\n         * touchableHandleLongPress: function\n         */\n\n        /**\n         * Returns the number of millis to wait before triggering a highlight.\n         *\n         * @abstract\n         * touchableGetHighlightDelayMS: function\n         */\n\n        /**\n         * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n         * numbers mean the size expands outwards.\n         *\n         * @abstract\n         * touchableGetPressRectOffset: function\n         */\n\n\n\n        // ==== Internal Logic ====\n\n        /**\n         * Measures the `HitRect` node on activation. The Bounding rectangle is with\n         * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n         * should result in points that are in the same coordinate system as an\n         * event's `globalX/globalY` data values.\n         *\n         * - Consider caching this for the lifetime of the component, or possibly\n         *   being able to share this cache between any `ScrollMap` view.\n         *\n         * @sideeffects\n         * @private\n         */\n        _remeasureMetricsOnActivation() {\n            // queryLayoutByID(\n            //   this.state.touchable.responderID,\n            //   null,\n            //   this._handleQueryLayout\n            // );\n        }\n\n        _handleQueryLayout(l, t, w, h, globalX, globalY) {\n            // this.state.touchable.positionOnActivate &&\n            // Position.release(this.state.touchable.positionOnActivate);\n            // this.state.touchable.dimensionsOnActivate &&\n            // BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);\n            // this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);\n            // this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);\n        }\n\n        _handleDelay(e) {\n            this.touchableDelayTimeout = null;\n            this._receiveSignal(Signals.DELAY, e);\n        }\n\n        _handleLongDelay(e) {\n            this.longPressDelayTimeout = null;\n            let curState = this.state.touchable.touchState;\n            if (curState !== States.RESPONDER_ACTIVE_PRESS_IN &&\n                curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n                console.error('Attempted to transition from state `' + curState + '` to `' +\n                    States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' +\n                    'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n            } else {\n                this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n            }\n        }\n\n        /**\n         * Receives a state machine signal, performs side effects of the transition\n         * and stores the new state. Validates the transition as well.\n         *\n         * @param {Signals} signal State machine signal.\n         * @throws Error if invalid state transition or unrecognized signal.\n         * @sideeffects\n         */\n        _receiveSignal(signal, e) {\n\n            let curState = this.state.touchable.touchState;\n            let nextState = Transitions[curState] && Transitions[curState][signal];\n            // if (!nextState) {\n            //   throw new Error(\n            //     'Unrecognized signal `' + signal + '` or state `' + curState +\n            //     '` for Touchable responder `' + this.state.touchable.responderID + '`'\n            //   );\n            // }\n            if (nextState === States.ERROR) {\n                throw new Error(\n                    'Touchable cannot transition from `' + curState + '` to `' + signal +\n                    '` for responder `' + this.state.touchable.responderID + '`'\n                );\n            }\n            if (curState !== nextState) {\n                this._performSideEffectsForTransition(curState, nextState, signal, e);\n                this.state.touchable.touchState = nextState;\n            }\n        }\n\n        _cancelLongPressDelayTimeout () {\n            this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n            this.longPressDelayTimeout = null;\n        }\n\n        _isHighlight (state) {\n            return state === States.RESPONDER_ACTIVE_PRESS_IN ||\n                state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n        }\n\n        _savePressInLocation(e) {\n            let touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);\n            let pageX = touch && touch.pageX;\n            let pageY = touch && touch.pageY;\n            let locationX = touch && touch.locationX;\n            let locationY = touch && touch.locationY;\n            this.pressInLocation = {pageX, pageY, locationX, locationY};\n        }\n\n        _getDistanceBetweenPoints (aX, aY, bX, bY) {\n            let deltaX = aX - bX;\n            let deltaY = aY - bY;\n            return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        }\n\n        /**\n         * Will perform a transition between touchable states, and identify any\n         * highlighting or unhighlighting that must be performed for this particular\n         * transition.\n         *\n         * @param {States} curState Current Touchable state.\n         * @param {States} nextState Next Touchable state.\n         * @param {Signal} signal Signal that triggered the transition.\n         * @param {Event} e Native event.\n         * @sideeffects\n         */\n        _performSideEffectsForTransition(curState, nextState, signal, e) {\n            let curIsHighlight = this._isHighlight(curState);\n            let newIsHighlight = this._isHighlight(nextState);\n\n            let isFinalSignal =\n                signal === Signals.RESPONDER_TERMINATED ||\n                signal === Signals.RESPONDER_RELEASE;\n\n            if (isFinalSignal) {\n                this._cancelLongPressDelayTimeout();\n            }\n\n            if (!IsActive[curState] && IsActive[nextState]) {\n                this._remeasureMetricsOnActivation();\n            }\n\n            if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n                this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n                // __dispatch({e, type: 'LongPress', target: this})\n            }\n            // console.log(newIsHighlight+\"*****\"+curIsHighlight);\n            if (newIsHighlight && !curIsHighlight) {\n                this._savePressInLocation(e);\n                this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n            } else if (!newIsHighlight && curIsHighlight && this.touchableHandleActivePressOut) {\n                if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n                    this.pressOutDelayTimeout = setTimeout(() => {\n                        this.touchableHandleActivePressOut(e);\n                    }, this.touchableGetPressOutDelayMS());\n                } else {\n                    this.touchableHandleActivePressOut(e);\n                }\n            }\n\n            if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n                let hasLongPressHandler = !!this.props.onLongPress;\n                let pressIsLongButStillCallOnPress =\n                    IsLongPressingIn[curState] && (    // We *are* long pressing..\n                        !hasLongPressHandler ||          // But either has no long handler\n                        !this.touchableLongPressCancelsPress() // or we're told to ignore it.\n                    );\n\n                let shouldInvokePress =  !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n                if (shouldInvokePress && this.touchableHandlePress) {\n                    // __dispatch({e, type: 'Press', target: this})\n                    //修复某些情况下点击TouchableOpacity时TextInput不会失去焦点，导致键盘被唤起的问题。\n                    if(global.document){\n                        if(global.document.activeElement !== e.nativeEvent.target){\n                            global.document.activeElement.blur && global.document.activeElement.blur();\n                            e.nativeEvent&& e.nativeEvent.target && e.nativeEvent.target.focus&&e.nativeEvent.target.focus();\n                        }\n                    }\n\n                    this.touchableHandlePress(e);\n                }\n            }\n\n            this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n            this.touchableDelayTimeout = null;\n        }\n    }\n\n    return TouchableMixin\n}\n\n"]}